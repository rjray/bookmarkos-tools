#!/usr/bin/env python3
"""A general script to produce a series of different reports on bookmarks data
as transformed to JSON by the `bookmarks2json` tool."""

import argparse
from bisect import bisect_left
from datetime import timedelta, datetime
from operator import attrgetter
import re
import sys
from typing import TextIO

from bookmarkos.data.bookmarks import Folder, Bookmark
from bookmarkos.data.metrics import Metrics
from bookmarkos.json_io import read_bookmarks_json
from bookmarkos.metrics import gather_metrics, differentiate_metrics, \
    all_bookmarks_sorted


def parse_command_line() -> argparse.Namespace:
    """Declaration of command-line parameters and parsing of them."""

    parser = argparse.ArgumentParser()

    parser.add_argument(
        'command', action='store', nargs=1,
        choices=['weekly'], help='Report to run'
    )
    parser.add_argument(
        'files', action='store', nargs='+',
        help='One or more JSON files to process'
    )

    return parser.parse_args()


def datetime_from_filename(file: str) -> datetime:
    """Scan the given file-name for a sequence of 8 digits, which will be
    interpreted as yyyy/mm/dd."""

    match = re.search(r'(\d\d\d\d)(\d\d)(\d\d)', file)
    if match is None:
        raise ValueError('File name does not contain date')

    # Create the `datetime` from the year/month/day. Seems like I should be
    # able to use `map` over `match.group(1, 2, 3)` here...?
    return datetime(
        int(match.group(1)), int(match.group(2)), int(match.group(3))
    )


def format_bookmark(bookmark: Bookmark) -> str:
    """Format the bookmark as a hyperlink."""

    created = datetime.fromtimestamp(bookmark.created).astimezone()
    timestamp = created.ctime()

    return f"{bookmark.name} ({timestamp})"


def output(lines: list[tuple[str, int | str]], fp: TextIO) -> None:
    """Output the pairs provided."""

    for label, value in lines:
        print(f"{label:25} {value}", file=fp)


def output_folders_weekly(these: Metrics, fp: TextIO) -> None:
    """Weekly output for folder metrics."""

    metrics = these.folders

    content: list[tuple[str, int | str]] = [('Total folders:', metrics.count)]
    if metrics.added_count:
        content.append(('Folders added:', metrics.added_count))
    if metrics.deleted_count:
        content.append(('Folders deleted:', metrics.deleted_count))
    if metrics.delta:
        content.append(
            (
                'Folders delta:',
                f'{metrics.delta} ({(metrics.delta_pct * 100):.2f}%)'
            )
        )

    if metrics.added_count:
        added = sorted(list(metrics.added))

        content.append(('    Added folders:', added[0]))
        for item in added[1:]:
            content.append(('', item))

    if metrics.deleted_count:
        deleted = sorted(list(metrics.deleted))

        content.append(('    Deleted folders:', deleted[0]))
        for item in deleted[1:]:
            content.append(('', item))

    content.append(
        (
            'Largest folder size:',
            max(metrics.sizes[x] for x in metrics.sizes.keys())
        )
    )
    content.append(
        (
            'Smallest folder size:',
            min(metrics.sizes[x] for x in metrics.sizes.keys())
        )
    )
    content.append(('Average folder size:', f'{metrics.avg_size:.2f}'))
    output(content, fp)


def output_bookmarks_weekly(
    these: Metrics,
    those_bookmarks: Folder,
    fp: TextIO
) -> None:
    """Weekly output for bookmark metrics."""

    metrics = these.bookmarks

    content: list[tuple[str, int | str]] = [
        ('Total bookmarks:', metrics.count)
    ]
    if metrics.added_count:
        content.append(('Bookmarks added:', metrics.added_count))
    if metrics.deleted_count:
        content.append(('Bookmarks deleted:', metrics.deleted_count))
    if metrics.delta:
        content.append(
            (
                'Bookmarks delta:',
                f"{metrics.delta} ({(metrics.delta_pct * 100):.2f}%)"
            )
        )

    if metrics.added_count:
        added = []
        for bookmark in metrics.new_bookmarks:
            added.append(format_bookmark(bookmark))

        content.append(('    Added bookmarks:', added[0]))
        for item in added[1:]:
            content.append(('', item))

    if metrics.deleted_count:
        # We tracked the full objects for added bookmarks, but only the IDs
        # (creation timestamps) for deleted bookmarks. So we need to look them
        # up in the previous week's data.
        bookmarks2 = all_bookmarks_sorted(those_bookmarks)
        deleted = []
        for item in sorted(list(metrics.deleted)):
            pos = bisect_left(bookmarks2, item, key=attrgetter('created'))
            deleted.append(format_bookmark(bookmarks2[pos]))

        content.append(('    Deleted bookmarks:', deleted[0]))
        for item in deleted[1:]:
            content.append(('', item))

    output(content, fp)


def output_tags_weekly(these: Metrics, fp: TextIO) -> None:
    """Weekly output for tag metrics."""

    metrics = these.tags

    content: list[tuple[str, int | str]] = [
        ('Total tags:', metrics.count),
        ('Unique tags:', metrics.unique_tags_count)
    ]
    if metrics.added_count:
        content.append(('New tags added:', metrics.added_count))
    if metrics.deleted_count:
        content.append(('Old tags deleted:', metrics.deleted_count))
    if metrics.delta:
        content.append(
            (
                'Tags delta:',
                f'{metrics.delta} ({(metrics.delta_pct * 100):.2f}%)'
            )
        )

    if metrics.added_count:
        added = sorted(list(metrics.added))

        content.append(('    Added tags:', added[0]))
        for item in added[1:]:
            content.append(('', item))

    if metrics.deleted_count:
        deleted = sorted(list(metrics.deleted))

        content.append(('    Deleted tags:', deleted[0]))
        for item in deleted[1:]:
            content.append(('', item))

    content.append(
        (
            'Largest tag size:',
            max(metrics.sizes[x] for x in metrics.sizes.keys())
        )
    )
    content.append(
        (
            'Smallest tag size:',
            min(metrics.sizes[x] for x in metrics.sizes.keys())
        )
    )
    content.append(('Average tag reach:', f'{metrics.avg_size:.2f}'))
    content.append(('Highest number of tags:', metrics.max_size))
    content.append(('Lowest number of tags:', metrics.min_size))
    output(content, fp)


def output_weekly(
        this_week: Metrics,
        last_week_bookmarks: Folder,
        fp: TextIO
) -> None:
    """Emit the weekly report content."""

    output_folders_weekly(this_week, fp)
    print(file=fp)
    output_bookmarks_weekly(this_week, last_week_bookmarks, fp)
    print(file=fp)
    output_tags_weekly(this_week, fp)


def weekly_report(args: argparse.Namespace, file: TextIO = sys.stdout):
    """Produce the weekly report."""

    if len(args.files) == 1:
        this_week_file = args.files[0]
        base_dt = datetime_from_filename(this_week_file)
        last_week_dt = base_dt - timedelta(weeks=1)
        last_week_str = last_week_dt.strftime('%Y%m%d')
        last_week_file = re.sub(r'\d{8}', last_week_str, this_week_file)
    else:
        last_week_file, this_week_file = args.files[:2]

    this_week_bookmarks = read_bookmarks_json(this_week_file)
    this_week = gather_metrics(this_week_bookmarks)
    last_week_bookmarks = read_bookmarks_json(last_week_file)
    last_week = gather_metrics(last_week_bookmarks)
    differentiate_metrics(this_week_bookmarks, this_week, last_week)

    output_weekly(this_week, last_week_bookmarks, file)


def main():
    """Main execution loop."""

    args = parse_command_line()

    weekly_report(args)


if __name__ == '__main__':
    main()
